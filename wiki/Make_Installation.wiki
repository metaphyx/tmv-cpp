#summary Instructions for installing TMV using make


= Installing using make =

This is a more standard installation method if you don't want to bother with SCons, or if you are just
more familiar with the make program and don't want to deal with SCons.  It requires a bit more
user input in terms of directly specifying the BLAS and/or LAPACK libraries, but because of that
it is also a bit easier to exactly customize the installation if you want to do something non-standard.

=== 1. Edit the `Makefile` ===
The start of the `Makefile` lists 5 things to specify: the compiler, the include directories, the other flags to send to the compiler,  any necessary BLAS/LAPACK linkage flags, and the installation directory.

The default setup is:
{{{
CC= g++
INCLUDE= -Iinclude
CFLAGS= $(INCLUDE) -O2 -DNOBLAS -DNDEBUG
BLASLIBS=
PREFIX=/usr/local
}}}
but you will probably want to change this.  (Note: The original version of the `Makefile` is copied in the file `Makefile.original` in case your copy gets messed up, and you want to go back to the original.)

This default setup will compile using g++ without any BLAS or LAPACK library and with debugging turned off. 
This setup should work on any system with gcc, although it almost certainly won't be as fast as using an optimized BLAS library and/or a LAPACK library.

You should edit these so that:
    * `CC` specifies the C++ compiler to use.
    * `INCLUDE` specifies the directories for any BLAS and LAPACK header files you want to include. (You should leave `-Iinclude` there as well.)
    * `CFLAGS` contains any compiler flags you want.  (See below for TMV-specific flags to consider.)
    * `BLASLIBS` specifies the libraries required for linking your BLAS and LAPACK libraries.
    * `PREFIX` specifies the directory for `make install` to copy the files to.

After these lines, there are several commented-out examples for different systems using various BLAS and LAPACK versions, showcasing some of the compiler options described below, and giving examples of what you need for several common (or at least representative) systems. If you have a system similar to one of these, then it should be a good starting point for you to figure out what you want to use.

=== 2. Compile Options ===
Here are some compiler flags to consider using:
    * `-DNDEBUG` will turn off debugging.  My recommendation is to leave debugging on in your own code that is calling TMV routines, since it doesn't slow things down too  much.  Then when you decide to export a version of the code that needs to be as fast as possible, recompile with this flag. On the other hand, the internal TMV code should be pretty well debugged when you get it, so for compiling the library, you should go ahead and use this flag.

The rest of the flags are only relevant when compiling the TMV library, so you won't need any of them when compiling your own code that uses TMV routines.  
    * `-DNO_INST_FLOAT` will not instantiate any `<float>` classes or routines.
    * `-DNO_INST_DOUBLE` will not instantiate any `<double>` classes or routines.
    * `-DNO_INST_COMPLEX` will not instantiate any complex classes or routines.
    * `-DINST_LONGDOUBLE` will instantiate `<long double>` classes and routines.
    * `-DINST_INT` will instantiate `<int>` classes and routines.

The next flags specify what BLAS and/or LAPACK libraries to use (if any):
    * `-DNOBLAS` will not call any external BLAS or LAPACK routines
    * `-DNOLAP` will not call any external LAPACK routines
    * `-DATLAS` will set up the BLAS calls as defined by ATLAS.  And (if -DNOLAP is not specified), it will also call the several LAPACK routines provided by ATLAS.
    * `-DCBLAS` will set up the BLAS calls using the notation provided by the  CBLAS interface to BLAS.  Many systems have a library like this installed as `/usr/local/lib/libcblas.a`, or some similar location, so it is worth looking to see if you have this before trying to install something new.
    * `-DFBLAS` will set up the BLAS calls using a library that was designed to be called from Fortran programs rather than C.  Most BLAS installations also install the C interface, but if your BLAS does not have this (e.g. GotoBLAS), then this flag should work.  Since there is often no header file for a Fortran BLAS library, we include the file `fblas.h` in the TMV `include` directory that should work.
    * `-DCLAPACK` will set up the LAPACK calls for the CLAPACK distribution.  I find this version easier to get installed than the Fortran LAPACK distribution, so I would recommend using this if you don't already have a version of LAPCK installed somewhere on you system.  Defining both ATLAS and CLAPACK will use the CLAPACK version for all LAPACK routines, including the ones also provided by ATLAS.  That is, ATLAS will only be used for its BLAS routines.  If you want the ATLAS versions of its few LAPACK routines instead, the ATLAS installation instructions describe a way to get them into the CLAPACK library. Also, you should make sure the `-I` directories lists the directory with the CLAPACK version of clapack.h before the ATLAS version.
    * `-DFLAPACK` will set up the LAPACK calls for a distribution that was designed to be called from Fortran programs rather than C.  Since such distributions do not provide a header file, we provide `flapack.h` in the TMV `include` directory. \index{LAPACK!Fortran LAPACK}
    * `-DMKL` will call all the external BLAS and LAPACK routines as defined by the Intel Math Kernel Library.  You should specify the directory with `mkl.h` with a `-I` flag if it is not installed in your include path.
    * `-DACML` will call all the external BLAS and LAPACK routines as defined by the AMD Core Math Library.  You should specify the directory with `acml.h` with a `-I` flag if it is not installed in your include path.

The next set of compiler defines are not usually necessary.  But if you have problems, these might be useful:
    * `-DXTEST=[num]` will do extra testing in the test suite, as well as add a few _O(N)_ time assert statements.  (Most of the assert statements that are normally run only take _O(1)_ time.)  I always do tests with `XTEST=127` to turn on all of the extra tests before releasing a version, but the executable gets quite large, as do many of the `TMV_Test*.o` files.  Plus it takes a lot longer to compile.  So the default is to not use it.  
    * `-DMEMTEST` will do extra testing of the memory usage to look for memory leaks and other memory errors.  Again, there is probably no need for you to use this flag.  But if you think there is a memory leak in TMV, this could help you find it, in which case please let me know.
    * `-DNOSTEGR` specifies that the LAPACK algorithm called `dstegr` (or `ssteg` for `<float>`) should not be used for symmetric eigenvector calculation.  In this case, the divide-and-conquer algorithm, named `dstedc` (or `sstedc`) will be used instead. I used to have problems with the `stegr` algorithm producing incorrect results, but I figured out how to detect the problem and now the TMV code starts by calling `stegr`, and then if it fails it calls the slower, but more robust, `stedc` routine.  If you want to avoid this behavior and always use the `stedc` algorithm, you can compile with this flag.
    * `-DNOGEQP3` specifies that the LAPACK algorithm called `dgeqp3` (or its variants) should not be used for the strict QRP decomposition. In this case, the native TMV code will be used instead.  I have found that the LAPACK code for `?geqp3` does not always produce an _R_ matrix with strictly decreasing elements along the diagonal.  So if this is important for you, then you should use this flag.
    * `-DNOWORKQUERY` specifies that your LAPACK library does not support work size queries.  There are a few LAPACK routines that require workspace whose optimal size depends on details of the L1 cache size of your machine.  Normally, you can pass the routine a work size of -1 to indicate that you are doing a workspace query, in which case the routine returns the optimal value to use.  This is the normal mode of operation for TMV.  However, some older LAPACK distributions do not support this process.  The example I found was the MKL with icc version 9.0. So if you get errors similar to `TMV Error: info < 0 returned by LAPACK function dormqr` then this flag will compile without the workspace queries, instead just using a good guess for the optimal size.
    * `-DNOMIX_SMALL` will avoid all arithmetic that mixes `SmallMatrix` and `SmallVector`  with regular `Matrix` or `Vector` in the test program `tmvtest3`. Some BLAS libraries -- specifically GotoBLAS, possibly others -- don't work with this kind of mixing, so this flag allows you to test the rest of the `Small` arithmetic if the mixing is causing problems for your system.  
    * `-DNOSTL` uses some workarounds for segments of code that use the STL library, but which didn't work for one of my compilers.  I'm pretty sure it is because the compiler wasn't installed correctly, so I don't think you should really ever need to use this flag.   But in any case, it will use a median-of-three quicksort algorithm for sorting rather than the standard library's sort.  And it manually reads strings  using character reads, rather than using the `>>` operator. 
    * `-DXDEBUG` will do different extra (much slower) debugging.  This one checks for incorrect results from the various algorithms by doing things the simple slow way and comparing the results to the fast blocked or recursive or in-place version to make sure the answer isn't (significantly) different.  I use this one a lot when debugging new algorithms, usually on a file-by-file basis.  Again, you shouldn't need this for an official release version.  But if you do get wrong answers for something, you could use this to try to find the problem.
    * `-DTMV_BLOCKSIZE=NN` will change the block size used by some routines.  The current value is 64, which is good for many computers.   The optimal value will depend on the size of your CPU's L1 cache.  So if you want to try to tune the algorithms, you can modify this value to something more appropriate for your computer.  However, you are probably better off just using an optimized BLAS and LAPACK library and let TMV call that instead.

=== 3. (Advanced usage) Edit the Inst and Blas files ===

By default, the library will include instantiations of all classes and functions that use either `double` or `float` (including complex versions of each).   There are a few flags, such as `-DNO_INST_FLOAT` and `-DINST_LONGDOUBLE`, that change this as described above.  

But if you want to compile routines for some other class, such as a user-defined `MyQuadPrecisionType` class, then you will need to modify the file `src/TMV_Inst.h`.

You simply need to add the lines:
{{{
#define T MyQuadPrecisionType
#include InstFile
#undef T
}}}
to the end of the file before compiling.  (Obviously, you should replace `MyQuadPrecisionType` with whatever type you want to be instantiated in the library.)

Also, the file `src/TMV_Blas.h` sets up all the BLAS and LAPACK calling structures, as well as the necessary `#include` statements.   So if the BLAS or LAPACK options aren't working for your system, you may need to edit these files as well. This is especially true if your BLAS or LAPACK versions are not one of  ATLAS, CLAPACK, FLAPACK, MKL, or ACML.  The comments at the beginning of `TMV_Blas.h` gives instructions on how to set up the file for  other installations.

=== 4. Build TMV library ===
Type:
{{{
make libs
}}}

This will make the TMV libraries, ```libtmv.a``` and ```libtmv_symband.a```, which will be located in the directory `lib`.

=== 5. Build test suite (Optional) ===
Type
{{{
make test
}}}

This will make three executables called `tmvtest1`, `tmvtest2` and `tmvtest3` in the `bin` directory.

Then you should run the three test suites. They should output a bunch of lines reading _Something_` passed all tests`. If one of them ends in a line that starts with `Error`, then please post a bug report at [http://code.google.com/p/tmv-cpp/issues/list] about the problem including what compiler you are using, some details about your system, and what (if any) BLAS and LAPACK libraries you are linking to.

=== 6. Install library ===
Type:
{{{
make install
}}}
(or possibly `sudo make install` if you are installing into `/usr/local` or somewhere similar).

This will copy the header files and the libraries to `PREFIX/include` and `PREFIX/lib`.  The default `PREFIX` is `/usr/local`, but you can change this in the `Makefile` to some other installation directory if you want.

=== 7. Compile you program ===

Each `.cpp` file that uses TMV will need to have
{{{
#include "TMV.h"
}}}
at the top.  If you are using any of the special matrix types (other than diagonal and triangular),
then you also need to include their particular header files as well. (e.g.
`TMV_Band.h`, `TMV_Small.h`, etc.)

If you did not install the header files (with `make install` above) to a directory that is in the standard path for header files, then you will need to use the compile flag `-IPREFIX/include` when making the object file to tell the compiler where the TMV header files are.  

For the linking step, you need to compile with the flag `-ltmv`.  If you are using band, symmetric or symmetric band matrices in your code, then you will need to link with the flags `-ltmv_symband -ltmv`. And if you did not install the libraries to a directory in your linking path, then you need to include the flag`-LPREFIX/lib` to tell the linker where the libraries are.

If you are using BLAS and/or LAPACK calls from the TMV code, then you will also need to 
link with their libraries.  For example, for my version of Intel's Math Kernel LIbrary, I use 
`-lmkl_lapack -lmkl_ia32 -lguide -lpthread`. For ATLAS, I use `-llapack -lcblas -latlas`.  For your specific installation, you may need the same thing, or something slightly different, including possibly `-L` flags to indicate where the BLAS or LAPACK libraries are located.
