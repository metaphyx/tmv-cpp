Changes from version 0.65 to 0.66:  
(See the History section in the full documentation for changes from previous
versions to 0.65.)

Deprecated features:

-- Changed the behavior of the m << 1, 2, 3... initialization.  Now the items 
   in the initialization list should be in RowMajor order regardless of the 
   storage order of the matrix \tt{m}.  This makes it much easier to 
   understand the initialization, since the list can be arranged to look like 
   the matrix you are setting.  e.g. the snippet:

   tmv::Matrix<double> m(3,5);
   m << 3 ,  9 ,  1 ,  4 ,  2 ,
        7 , -3 ,  0 , -1 ,  4 ,
       -6 ,  2 , 11 ,  5 ,  6 ;

   now initializes the matrix to have the values as shown in the rectangle.  
   However, the old behavior was to follow the storage order of the matrix, 
   and since the default storage order is ColMajor, this would unintuitively 
   initialize the matrix to

   (  3   4  -3   4  11  )
   (  9   2   0  -6   5  )
   (  1   7  -1   2   6  )
   
   rather than the obviously intended matrix
   
   (  3   9   1   4   2  )
   (  7  -3   0  -1   4  )
   ( -6   2  11   5   6  )

   Now the code correctly initializes the matrix to the second one regardless 
   of how the matrix intrinsically stores the values, which I believe is a 
   much more intuitive behavior.

   Of course, if you do want to initialize according to a ColMajor list of 
   numbers for some reason, you can initialize \tt{m.transpose()} instead:

   tmv::Matrix<double> m(3,5);
   m.transpose() << 3 ,  7 , -6 ,
                    9 , -3 ,  2 ,
                    1 ,  0 , 11 ,
                    4 , -1 ,  5 ,
                    2 ,  4 ,  6 ,

-- Deprecated the constructors from either a C-style array or a std::vector.  
   The reason is similar to the reasoning above -- I wanted to decouple the 
   internal storage order from the order of the elements in the initializing 
   vector.

   To take the place of these constructors' functionality, I added iterators 
   that iterate over the matrix in either RowMajor or ColMajor order, so the 
   assignment can be done with the standard library's \tt{std::copy} function.

   const double rmar[15] =
       { 3, 9, 1, 4, 2, 7, -3, 0, -1, 4, -6, 2, 11, 5, 6};
   const double cmar[15] =
       { 3, 7, -6, 9, -3, 2, 1, 0, 11, 4, -1, 5, 2, 4, 6};

   // Old style constuctors: (now deprecated)
   tmv::Matrix<double,tmv::RowMajor> m1(3,5,rmar);
   tmv::Matrix<double,tmv::ColMajor> m2(3,5,cmar);

   // New style assignment with iterators:
   tmv::Matrix<double> m3(3,5); // Can be either StorageType
   std::copy(rmar, rmar+15, m3.rowmajor_begin());
   tmv::Matrix<double> m4(3,5);
   std::copy(cmar, cmar+15, m3.colmajor_begin());

   In addition, a BandMatrix can be iterated in DiagMajor order using 
   m.diagmajor_begin().

-- Deprecated the routines that returned pointers to new BaseMatrixes.  
   In general, using the \tt{BaseMatrix} class directly is not really very 
   useful, so I don't think anyone is actually using these methods.  And in 
   the version 0.9 TMV code in development, I've completely redesigned the 
   back end.  It gets rid of the virtual class hierarchy completely using the 
   CRTP idiom rather than virtual functions.  But this means that methods like 
   newCopy(), newTranspose(), etc. are not really relevant anymore.

   If you were using these functions and are sorry to see them go, or if you 
   are otherwise using the virtual functionality (e.g. with 
   std::vector<tmv::BaseMatrix*>), let me know what your use case was 
   (at tmv-discuss@googlegroups.com) and we can try to figure out how best to 
   incorporate your needs into the version 0.9 code.


New features:

-- Added the matrix iterators described above.

-- Added the ability to do comma initialization for DiagMatrix, UpperTriMatrix,
  LowerTriMatrix, BandMatrix, and their corresponding view types.
  These are also always listed in RowMajor order regardless of the actual 
  storage order of the matrix in memory.  Also, only the values in the 
  corresponding parts of the matrices should be listed in the initialization.
  e.g.

  tmv::DiagMatrix<double> d(4);
  d << 4,
          9, 
            11,
               -4 ;
  tmv::UpperTriMatrix<double> u(4);
  u << 4 ,  9 , -1 ,  0 ,
           18 ,  3 , -7 ,
                 1 ,  5 ,
                     10 ;
  tmv::LowerTriMatrix<double> l(4);
  l <<  1 ,
       12 , -3 ,
        8 ,  5 , -9 ,
        3 , 20 , 14 ,  4 ;
  tmv::BandMatrix<double> b(4,1,1);
  b <<  7 ,  9 ,
       10 , -1 ,  5 ,
             8 , -6 , 21 , 
                  2 ,  8 ;
  I chose not to add similar initializers for symmetric or hermitian matrix
  types, because I think initialization of them is clearer in terms of only
  the upper or lower triangle part that is stored in memory.  So the way to 
  initialize them would be something like:
  
  tmv::SymMatrix<double> s(4);
  s.upperTri() << 2 ,  1 , -3 ,  7 ,
                      -8 , -2 , 12 ,
                            6 ,  1 ,
			         7 ;
  tmv::SymBandMatrix<double> sb(4,1);
  sb.lowerBand() <<  8 ,
                    12 ,  5 ,
		         -8 ,  2 ,
			       6 , 10 ;

-- Added a few more "ViewOf" functions to allow direct views of memory as 
   different kinds of matrix types directly specifying the step in each 
   direction.  These are more flexible than the versions that merely specify a
   StorageType to use.  For non-contiguous data, those weren't sufficient.
   So now, you can view arbitrary data in memory as an UpperTriMatrixView, 
   LowerTriMatrixView, DiagMatrixView, BandMatrixView, SymMatrixView, or 
   SymBandMatrixView specifying the memory address of m(0,0) and the step 
   size in each direction.


Bug fixes:

-- Added support for the clang++ compiler.  This didn't require much editing, 
   but it did complain about a couple things that had passed muster with the 
   other compilers I had used.


